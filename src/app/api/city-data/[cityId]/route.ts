import { NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';
import { Firestore } from '@google-cloud/firestore';
import type { ROIReport, ROIRegion } from '@/types/roi';

// --- Configuration ---
const PROJECT_ID = process.env.PROJECT_ID;
const FIRESTORE_ID = process.env.FIRESTORE_ID;

// Helper to determine Map Center (Shared logic)
function getMapConfig(cityId: string) {
  return cityId === 'milan' 
      ? { center: { lat: 45.4642, lng: 9.1900 }, zoom: 11 }
      : { center: { lat: 52.5200, lng: 13.4050 }, zoom: 10 };
}

// Helper: Calculate Centroid
const calculateCentroid = (coords: { lat: number; lng: number }[]) => {
  if (!coords || coords.length === 0) return { lat: 0, lng: 0 };
  let latSum = 0;
  let lngSum = 0;
  for (const coord of coords) {
    latSum += coord.lat;
    lngSum += coord.lng;
  }
  return { lat: latSum / coords.length, lng: lngSum / coords.length };
};

// --- NEW: Assemble Report from Live Firestore Data ---
async function assembleReportFromFirestore(cityId: string, cityName: string): Promise<ROIReport | null> {
    const db = new Firestore({ projectId: PROJECT_ID, databaseId: FIRESTORE_ID });
    
    // Query the new collection structure: cities/{cityId}/regions
    const regionsRef = db.collection('cities').doc(cityId).collection('regions');
    const snapshot = await regionsRef.get();

    if (snapshot.empty) {
        return null; // Fallback to files if no live data exists
    }

    const regions: ROIRegion[] = [];
    
    snapshot.forEach(doc => {
        const data = doc.data();
        
        // Transform Firestore data to ROIRegion
        // Note: We handle cases where the agent hasn't finished calculating financials yet
        regions.push({
            id: doc.id,
            name: data.name || doc.id,
            // Handle Coordinates (Stored as array or object in FS?)
            // Assuming the agent backend stores them as {lat, lng} or [lng, lat]
            coordinates: data.coordinates ? { lat: data.coordinates[1], lng: data.coordinates[0] } : { lat: 0, lng: 0 }, 
            
            // Reconstruct Polygon from stored geometry if available
            polygonCoordinates: data.geometry?.coordinates?.[0]?.map((p: number[]) => ({ lat: p[1], lng: p[0] })) || [],
            
            roiPercentage: data.roiPercentage || 0,
            projectedRevenue: data.projectedRevenue ? `€${(data.projectedRevenue).toLocaleString()}` : 'Pending...',
            projectedCost: data.projectedCost || 0,
            netProfit: data.netProfit || 0,
            timeline: "24 Months",
            
            // Text Fields
            executiveSummary: data.executive_summary || "Analysis Pending",
            details: data.detailed_report || "Analysis in progress...",
            
            // Placeholder for specific fields if not yet generated by simplified agent
            marketSizeAndDensity: data.marketSizeAndDensity || "Available in full report",
            demographicProfile: "Available in full report",
            projectedDemand: "Available in full report",
            deploymentComplexity: "Available in full report",
            laborAndResourceCosts: "Available in full report",
            incumbentAnalysis: "Available in full report",
            competitivePricing: "Available in full report",
            permittingAndRegulation: "Available in full report",
            esgImpactScore: "Available in full report",
            detailed_report: data.detailed_report || "",
            deepResearchReportUrl: "",
        });
    });

    // Sort by ROI
    regions.sort((a, b) => b.roiPercentage - a.roiPercentage);
    
    const mapConfig = getMapConfig(cityId);

    return {
        city: cityName,
        mapCenter: mapConfig.center,
        mapZoom: mapConfig.zoom,
        executive_summary: `Live analysis for ${cityName}`, // You might want to store a city-level summary in Firestore too
        regions: regions
    };
}

// --- OLD: Assemble Report from Static Files (Legacy Support) ---
function assembleReportFromFiles(geojsonDocData: any, reportDocData: any, cityName: string, cityId: string): ROIReport {
    // ... [Existing Parsing Logic - Kept for fallback] ...
    // (I am condensing this block for brevity, but in the actual file, 
    //  you should keep your robust error checking logic here)
    
    const features = geojsonDocData.features || (geojsonDocData.type === 'Feature' ? [geojsonDocData] : []);
    const parsingErrors: string[] = [];
    
    const combinedRegions = features.map((feature: any) => {
        const props = feature.properties || {};
        const regionId = props?.id || props?.name || props?.sub_area_name;
        if(!regionId) return null;

        const opportunity = reportDocData.ranked_opportunities?.find((o: any) => o.sub_area_name.toLowerCase() === regionId.toLowerCase());
        if (!opportunity) return null;

        let polygonCoordinates: { lat: number; lng: number }[] = [];
        // simplified geometry parsing for brevity in this example
        if(feature.geometry.type === 'Polygon') {
             polygonCoordinates = feature.geometry.coordinates[0].map((c:number[]) => ({ lat: c[1], lng: c[0] }));
        } else if (feature.geometry.type === 'MultiPolygon') {
             polygonCoordinates = feature.geometry.coordinates[0][0].map((c:number[]) => ({ lat: c[1], lng: c[0] }));
        }

        const financials = opportunity.financials || {};
        
        return {
            id: regionId,
            name: opportunity.sub_area_name,
            coordinates: calculateCentroid(polygonCoordinates),
            polygonCoordinates,
            roiPercentage: financials.estimated_roi_percentage || 0,
            projectedRevenue: `€${(financials.total_projected_revenue_usd || 0).toLocaleString()}`,
            projectedCost: financials.total_projected_cost_usd || 0,
            netProfit: financials.net_profit || 0,
            timeline: "24 Months",
            executiveSummary: reportDocData.executive_summary,
            details: opportunity.detailed_report || "",
            // ... (rest of mappings)
            marketSizeAndDensity: "", 
            demographicProfile: "", 
            projectedDemand: "", 
            deploymentComplexity: "", 
            laborAndResourceCosts: "", 
            incumbentAnalysis: "", 
            competitivePricing: "", 
            permittingAndRegulation: "", 
            esgImpactScore: "", 
            detailed_report: opportunity.detailed_report,
            deepResearchReportUrl: "",
        } as ROIRegion;
    }).filter((r: any) => r !== null);

    const mapConfig = getMapConfig(cityId);
    return {
        city: cityName,
        mapCenter: mapConfig.center,
        mapZoom: mapConfig.zoom,
        executive_summary: reportDocData.executive_summary,
        regions: combinedRegions
    };
}


// --- MAIN GET HANDLER ---
export async function GET(
  request: Request,
  { params }: { params: Promise<{ cityId: string }> }
) {
  const { cityId } = await params;

  const AVAILABLE_CITIES = [
    { id: "berlin", name: "Berlin" },
    { id: "milan", name: "Milan" },
  ];
  const cityName = AVAILABLE_CITIES.find(c => c.id === cityId)?.name;

  if (!cityName) {
    return NextResponse.json({ error: 'Invalid city' }, { status: 404 });
  }

  try {
    // STRATEGY 1: Try fetching from the new "Live" Firestore collection first
    try {
        if (PROJECT_ID) {
            const liveReport = await assembleReportFromFirestore(cityId, cityName);
            if (liveReport && liveReport.regions.length > 0) {
                console.log(`[API] Serving live Firestore data for ${cityName}`);
                return NextResponse.json(liveReport);
            }
        }
    } catch (fsError) {
        console.warn(`[API] Failed to fetch live data (falling back to files):`, fsError);
    }

    // STRATEGY 2: Fallback to Local Files (Legacy/Dev)
    console.log(`[API] Serving local static files for ${cityName}`);
    const dataDir = path.join(process.cwd(), 'data');
    const reportPath = path.join(dataDir, `${cityId}.report.json`);
    let geojsonPath = path.join(dataDir, `${cityId}.geojson`);
    
    // File reading logic...
    try {
        await fs.access(geojsonPath);
    } catch {
        geojsonPath = path.join(dataDir, `${cityId}.json`);
    }

    const [geojsonContent, reportContent] = await Promise.all([
        fs.readFile(geojsonPath, 'utf8'),
        fs.readFile(reportPath, 'utf8')
    ]);

    const geojsonDocData = JSON.parse(geojsonContent);
    const reportDocData = JSON.parse(reportContent);

    const report = assembleReportFromFiles(geojsonDocData, reportDocData, cityName, cityId);
    return NextResponse.json(report);

  } catch (error: any) {
    console.error(`Failed to get data for ${cityId}:`, error);
    return NextResponse.json({ error: error.message || 'An internal server error occurred' }, { status: 500 });
  }
}